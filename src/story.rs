pub fn render_story_markdown(
    matched: &str,
    count: usize,
    occ_index: usize,
    neighbor: Option<usize>,
    call_sites: usize,
    span: Option<usize>,
    density: usize,
    signals: &[String],
    confidence: u8,
    nearest_call: Option<(usize, usize, usize)>,
    id_hint: &str,
    source_label: &str,
) -> String {
    // Build a human-friendly heuristics-based paragraph describing the occurrence.
    let mut out = String::new();

    // Header (keep legacy 'Story:' substring for compatibility)
    out.push_str("Story: ");
    out.push_str(&format!("**{}`{}`**\n\n", "Story — ", matched));

    // Frequency summary
    let freq = if count == 1 {
        "appears once".to_string()
    } else {
        format!("appears {} times", count)
    };
    let occ = format!("This occurrence is {}/{} of the total.", occ_index + 1, count);
    out.push_str(&format!("- **Frequency:** {}. {}\n", freq, occ));

    // Density and spread
    let spread = match span {
        Some(s) => {
            let density_desc = if density > 50 { "dense" } else { "sparse" };
            format!("spans ~{} bytes ({}).", s, density_desc)
        }
        None => "spread not applicable".to_string(),
    };
    out.push_str(&format!("- **Distribution:** {}\n", spread));

    // Neighbor distance
    if let Some(n) = neighbor {
        out.push_str(&format!("- **Local proximity:** nearest similar occurrence ~{} bytes away.\n", n));
    }

    // Call site info
    if call_sites > 0 {
        let near = nearest_call.map(|(l, c, d)| format!("nearest call at L{} C{} (~{} bytes)", l, c, d)).unwrap_or_default();
        out.push_str(&format!("- **Call-sites:** {} detected; {}\n", call_sites, near));
    } else {
        out.push_str("- **Call-sites:** none detected near this token.\n");
    }

    // Signals and confidence
    if !signals.is_empty() {
        let s = signals.join(", ");
        out.push_str(&format!("- **Signals:** {}.\n", s));
    }
    out.push_str(&format!("- **Confidence:** {}/10 based on heuristics.\n", confidence));

    // Identifier hint
    if !id_hint.is_empty() {
        out.push_str(&format!("- **Identifier hint:** {}.\n", id_hint.trim_start_matches("; ")));
    }

    // Actionable guidance
    let mut guidance = Vec::new();
    if signals.iter().any(|s| s == "high-risk-keyword" || s == "id-hint") || confidence >= 7 {
        guidance.push("Treat as high-priority for review");
    } else if signals.iter().any(|s| s == "keyword-hint") || confidence >= 4 {
        guidance.push("Flag for manual review");
    } else {
        guidance.push("Consider as low priority or documentation reference");
    }
    // If there are call-sites, suggest checking usage
    if call_sites > 0 {
        guidance.push("Inspect nearby call sites to see how the token is used");
    }
    out.push_str(&format!("\n**Guidance:** {}.\n", guidance.join("; ")));

    // Small provenance note
    out.push_str(&format!("\n_Source: {} — generated by heuristics._\n", source_label));

    // Legacy marker for consumers/tests that search for lowercase tokens
    out.push_str("\ncall-sites\n");

    out
}
