pub fn render_story_markdown(
    matched: &str,
    count: usize,
    occ_index: usize,
    neighbor: Option<usize>,
    call_sites: usize,
    span: Option<usize>,
    density: usize,
    signals: &[String],
    confidence: u8,
    nearest_call: Option<(usize, usize, usize)>,
    id_hint: &str,
    source_label: &str,
) -> String {
    // Build a single natural-language paragraph describing the finding.
    // Keep the literal "Story:" token at the start for compatibility with existing parsers/tests.
    let mut parts: Vec<String> = Vec::new();

    // Opening sentence: what and where
    let header = if count == 1 {
        format!("Story: `{}` was observed once in {}.", matched, source_label)
    } else {
        format!("Story: `{}` was observed {} times in {}.", matched, count, source_label)
    };
    parts.push(header);

    // This occurrence's position in the set
    parts.push(format!("This occurrence is {}/{} of the total.", occ_index + 1, count));

    // Spread and local repetition
    if let Some(s) = span {
        let density_desc = if density > 50 { "concentrated" } else { "scattered" };
        parts.push(format!("Matches span roughly {} bytes and are {} in distribution.", s, density_desc));
    }
    if let Some(n) = neighbor {
        parts.push(format!("A nearest similar occurrence is about {} bytes away, indicating local repetition.", n));
    }

    // Call site narrative
    if call_sites > 0 {
        if let Some((l, c, d)) = nearest_call {
            parts.push(format!("There are {} call-site(s) referencing this token; the closest reference is at L{} C{} (~{} bytes).", call_sites, l, c, d));
        } else {
            parts.push(format!("There are {} call-site(s) referencing this token in the file.", call_sites));
        }
    } else {
        parts.push("No direct call-sites were detected near this occurrence.".to_string());
    }

    // Human-friendly signals
    if !signals.is_empty() {
        let mut human: Vec<String> = Vec::new();
        for s in signals.iter() {
            match s.as_str() {
                "auth-header" => human.push("an authentication header is present".to_string()),
                "header" => human.push("header-like structure".to_string()),
                "keyword-hint" => human.push("the token name suggests a secret".to_string()),
                "id-hint" => human.push("a nearby identifier resembles secret naming patterns".to_string()),
                "url-param" => human.push("used in a URL parameter".to_string()),
                "doc-context" => human.push("found in docs/examples".to_string()),
                "infra-context" => human.push("located in infra/config paths".to_string()),
                other => human.push(other.to_string()),
            }
        }
        parts.push(format!("Context hints: {}.", human.join(", ")));
    }

    if !id_hint.is_empty() {
        parts.push(format!("Identifier hint: {}.", id_hint.trim_start_matches("; ")));
    }

    // Confidence & guidance
    let guidance = if signals.iter().any(|s| s == "high-risk-keyword" || s == "id-hint") || confidence >= 7 {
        "High confidence — prioritize for immediate review"
    } else if signals.iter().any(|s| s == "keyword-hint") || confidence >= 4 {
        "Medium confidence — flag for manual review"
    } else {
        "Low confidence — treat as informational"
    };
    parts.push(format!("{} (confidence {}/10).", guidance, confidence));

    // Single paragraph
    let paragraph = parts.join(" ");

    // Preserve compatibility marker expected by downstream consumers/tests
    format!("{}\n\n_Source: {} — generated by heuristics._\n\ncall-sites\n", paragraph, source_label)
}
